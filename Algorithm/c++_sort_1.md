## C++ 정렬(Sort) Algorithm 정리1 [C++]



- Sorting은 자료들을 크기 순서대로(오름차순 or 내림차순)으로 나열하는 것

- 정렬에는 기본적인 **선택정렬**, **버블정렬**, **삽입정렬** 등이 존재

- 조금 복잡한 **병학정렬**, **퀵정렬**, **힙정렬**, **기수정렬**  등도 존재

  

  ------

  

  #### Stable 정렬 알고리즘

  > 정렬할 자료들 중에서 동일한 두 자료의 위치가 정렬 후에도 똑같이 유지되는 정렬 알고리즘
  >
  > Ex) 5(1), 2, 1, 5(2) -> 1, 2, 5(1), 5(2) : stable 알고리즘
  >
  > 버블정렬, 삽입정렬이 Stable 알고리즘

  

  #### In-place 정렬 알고리즘

  > 입력을 저장하는 메모리 외에 추가로 사용하는 메모리 공간이 O(1)인 정렬 알고리즘
  >
  > 추가로 사용하는 메모리 공간이 상수인 정렬 알고리즘을 이야기함!
  >
  > 선택정렬, 버블정렬, 삽입정렬이 In-place 알고리즘

  

------



#### 선택 정렬

- 각 루프마다 최대(최소) 원소를 찾아 그 원소와 마지막 원소를 교환
- 마지막 원소는 제외
- 하나의 원소만 남을 때까지 루프를 반복
- 최악의 경우 시간복잡도: O(n2)

```c++
// a = 배열 , n = 배열의 사이즈
void selectionSort(int a[], int n) {
  // i 와 index 에 최대값을 넣기
  for(int i = n-1; i > 0; i--) {
    int index = 0;
    for(int j = 1; j <=i; j++) {
      if(a[index] < a[j])
        index = j;
    }
    // 교환
    int temp = a[index];
    a[index] = a[i];
    a[i] = temp;
  }
}
```



#### 버블 정렬

- 처음부터 마지막까지 차례대로 인접한 두 원소를 비교하여 뒤에 있는 원소가 앞의 원소보다 작으면 두 원소를 교환
- 마지막 원소는 제외
- 끝까지 가면서 교환이 일어나지 않으면 정렬이 되어 있는 상태
- 수행시간: O(n2)

```c++
// a = 배열 , n = 배열의 사이즈
void bubbleSort(int a[], int n) {
  for(int i = n-1; i > 0; i--) {
    for(int j = 0; j < i; j++) {
      // 인접한 두개를 비교했을 경우 앞의 원소가 뒤의 원소보다 큰 경우 교환
      if(a[j] > a[j+1]) {
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
      }
    }
  }
}
```



#### 개선된 버블 정렬

- 교환이 일어나지 않으면 정렬이 되어 있다고 간주하고 종료
- 최악의 경우: O(n2) -> 역순으로 정렬된 경우
- 가장 좋은 경우: O(n) -> 정렬된 경우

```c++
// a = 배열 , n = 배열의 사이즈
void bubbleSort(int a[], int n) {
  for(int i = n-1; i > 0; i--) {
    int sorted = 1; // 정렬되어 있는지 여부 판단용 변수
    for(int j = 0; j < i; j++) {
      // 인접한 두개를 비교했을 경우 앞의 원소가 뒤의 원소보다 큰 경우 교환
      if(a[j] > a[j+1]) {
        int temp = a[j];
        a[j] = a[j+1];
        a[j+1] = temp;
        sorted = 0; // 교환이 일어나면 정렬 x
      }
      if(sorted == 1) // 교환이 안 일어난 경우 = 정렬 O
        break;
    }
  }
}
```



#### 삽입 정렬

- 첫번째 원소부터 마지막 전까지 정렬되어 있을때 원소 하나를 추가해서 비교하여 교환
- 하나씩 밀어주는 개념
- 평균적인 경우 시간복잡도: O(n2)

```c++
// a = 배열 , n = 배열의 사이즈
void insertSort(int a[], int n) {
  for(int i = 1; i < n; i++) {
    int temp = a[i];
    for(int j = n-1; j >=0; j--) {
      if(a[j] > temp)  // 비교
        a[j+1] = a[j];
      else
        break;
    }
    a[j+1] = temp;
  }
}
```

